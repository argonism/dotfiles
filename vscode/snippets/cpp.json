{
	"greatest common divisor": {
		"prefix": "gcd",
		"body": [
			"template <typename integer>",
			"integer gcd(integer a, integer b) {",
			"    integer c = max(a, b);",
			"    integer d = min(a, b);",
			"    if (d != 0) return gcd(d, c % d);",
			"    else return a;"
		]
	},
	"least common divisor": {
		"prefix": "lcm",
		"body": [
			"template <typename integer>",
			"integer gcd(integer a, integer b) {",
			"    integer c = max(a, b);",
			"    integer d = min(a, b);",
			"    if (d != 0) return gcd(d, d%c);",
			"    else return a;",
			"}",
			"",
			"template<typename integer>",
			"integer lcm(integer a, integer b) {",
			"    return (a * b) / gcd(a, b);",
			"}"
		]
	},
	"prime factorization": {
		"prefix": "prime",
		"body": [
			"std::vector<std::pair<long long, int>> factor(long long base) {",
			"    long long ret = 1e18;",
			"    vector<pair<long long, int>> fs;",
			"",
			"    for (long long i=2; i*i < base; i++) {",
			"        if (base % i == 0) {",
			"            int cnt = 0;",
			"",
			"            while (base % i == 0) {",
			"                base /= i;",
			"                cnt++;",
			"                fs.emplace_back(i, cnt);",
			"            }",
			"        }",
			"    }",
			"    if (base > 1) {",
			"        fs.emplace_back(base, 1);",
			"    }",
			"",
			"    return fs;",
			"}"
		]
	},
	"union find": {
		"prefix": "uf",
		"body": [
			"class UnionFind {",
			"    public:",
			"        // contain parent node_index",
			"        // if the node_id is root, -size(group)",
			"        vector<int> parent;",
			"        long long root(int);",
			"        long long size(int);",
			"",
			"        // judging functions",
			"        bool join(int, int);",
			"        bool same(int, int);",
			"",
			"        UnionFind(int x) {",
			"            parent = vector<int>(x, -1);",
			"        };",
			"",
			"};",
			"",
			"",
			"long long UnionFind::root(int node_id) {",
			"    if (parent[node_id] < 0) return node_id;",
			"    else return parent[node_id] = UnionFind::root(parent[node_id]);",
			"}",
			"",
			"",
			"long long UnionFind::size(int node_id) {",
			"    return -parent[UnionFind::root(node_id)];",
			"}",
			"",
			"",
			"bool UnionFind::same(int source_node_id, int target_node_id) {",
			"    return UnionFind::root(source_node_id) == UnionFind::root(target_node_id);",
			"}",
			"",
			"",
			"bool UnionFind::join(int source_node_id, int target_node_id) {",
			"    int a = UnionFind::root(source_node_id);",
			"    int b = UnionFind::root(target_node_id);",
			"    if (a == b) return false;",
			"",
			"    if (UnionFind::size(a) < UnionFind::size(b)) swap(a, b);",
			"    parent[a] += parent[b];",
			"    parent[b] = a;",
			"",
			"    return true;",
			"}"
		]
	}
}
